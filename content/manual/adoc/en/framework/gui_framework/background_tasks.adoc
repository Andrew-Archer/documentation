:sourcesdir: ../../../../source

[[background_tasks]]
==== Background Tasks

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=standard-progressbar" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Background tasks mechanism is designed for performing tasks at the client tier asynchronously without blocking the user interface.

In order to use background tasks, do the following:

. Define a task as an inheritor of the `BackgroundTask` abstract class. Pass a link to a screen controller which will be associated with the task and the task timeout to the task constructor.
+
Closing the screen will interrupt the tasks associated with it. Additionally, the task will be interrupted automatically after the specified timeout.
+
Actual actions performed by the task are implemented in the <<background_tasks_run,run()>> method.

. Create an object of `BackgroundTaskHandler` class controlling the task by passing the task instance to the `handle()` method of the `BackgroundWorker` bean. A link to `BackgroundWorker` can be obtained by an injection in a <<screen_controller,screen controller>>, or through the `AppBeans` class.

. Run the task by invoking the `execute()` method of `BackgroundTaskHandler`.

[WARNING]
====
UI components' state and datasources must not be read/updated from `BackgroundTask` `run()` method: use `done()`, `progress()`, and `canceled()` callbacks instead. An `IllegalConcurrentAccessException` is thrown in case you try to set a value to UI component from a background thread.
====

Example:

[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_1.java[]
----

Detailed information about methods is provided in JavaDocs for `BackgroundTask`, `TaskLifeCycle`, `BackgroundTaskHandler` classes. 

Please note the following:

* `BackgroundTask<T, V>` is a parameterized class:

** `T` − the type of objects displaying task progress. Objects of this type are passed to the task's `progress()` method during an invocation of `TaskLifeCycle.publish()` in the working thread.

** `V` − task result type passed to the `done()` method. It can also be obtained by invoking `BackgroundTaskHandler.getResult()` method, which will wait for a task to complete.

* `canceled()` method is invoked only during a controlled cancellation of a task, i.e. when `cancel()` is invoked in the `TaskHandler`.

* `handleTimeoutException()` is invoked when the task timeout expires. If the window where the task is running closes, the task is stopped without a notification.

[[background_tasks_run]]
* `run()` method of a task should support external interruptions. To ensure this, we recommend checking the `TaskLifeCycle.isInterrupted()` flag periodically during long processes and stopping execution when needed. Additionally, you should not silently discard `InterruptedException` (or any other exception) - instead you should either exit the method correctly or not handle the exception at all.
+
** `isCancelled()` method returns `true` if a task was interrupted by calling the `cancel()` method.
+
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_2.java[]
----

* `BackgroundTask` objects are stateless. If you did not create fields for temporary data when implementing task class, you can start several parallel processes using a single task instance.

* `BackgroundHandler` object (its `execute()` method) can only be started once. If you need to restart a task frequently, use `BackgroundTaskWrapper` class.

* Use `BackgroundWorkWindow` or `BackgroundWorkProgressWindow` classes with a set of static methods to show a modal window with progress indicator and *Cancel* button. You can define progress indication type and allow or prohibit cancellation of the background task for the window.

* If you need to use certain values of visual components in the task thread, you should implement their acquisition in `getParams()` method, which runs in the UI thread once, when a task starts. In the run() method, these parameters will be accessible via the `getParams()` method of the `TaskLifeCycle` object.

* If any exception occurs, the framework invokes `BackgroundTask.handleException()` method in the UI thread, which can be used to display the error.

* Background tasks are affected by <<cuba.backgroundWorker.maxActiveTasksCount,cuba.backgroundWorker.maxActiveTasksCount>> and <<cuba.backgroundWorker.timeoutCheckInterval,cuba.backgroundWorker.timeoutCheckInterval>> application properties.

[WARNING]
====
In Web Client, background tasks are implemented using HTTP push provided by the Vaadin framework. See https://vaadin.com/wiki/-/wiki/Main/Working+around+push+issues for information on how to set up your web servers for this technology.
====

[TIP]
====
If you don't use background tasks, but want to update UI state from a non-UI thread, use methods of the `UIAccessor` interface. You should get a reference to `UIAccessor` using the `BackgroundWorker.getUIAccessor()` method in the UI thread, and after that you can invoke its `access()` and `accessSynchronously()` methods from a background thread to safely read or modify the state of UI components.
====

[[background_task_examples]]
===== Background Task Usage Examples

Display and control background task operation with BackgroundWorkProgressWindow::
+
--
Often when launching a background task one needs to display a simple UI:
[loweralpha]
. to show to the user that requested action is in the process of execution,
. to allow user to abort requested long operation,
. to show operation progress if progress percent can be determined.

Platform satisfies these needs with `BackgroundWorkWindow` and `BackgroundWorkProgressWindow` utility classes.
These classes have static methods allowing to associate background task with a modal window that has a title, description, progress bar and optional `Cancel` button.
The difference between two classes is that `BackgroundWorkProgressWindow` uses determinate progress bar, and it should be used in case if you can estimate progress of the task.
Contrary, `BackgroundWorkWindow` should be used for tasks of indeterminate duration.

Consider the following development task as an example:

- A given screen contains a table displaying list of students, with multi-selection enabled.
- When user presses a button, system should send reminder emails to selected students, without blocking UI and with ability to cancel operation.

image::gui_bg_tasks/bg-task-emails.png[align="center"]

Sample implementation:
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_sample_emails.java[]
----
<1> - launch the task and show modal progress window
<2> - set dialog options: total number of elements for progress bar, user can cancel a task, show progress percent
<3> - task progress unit is `Integer` (number of processed table items), and result type is `Void` because this task doesn't produce result
<4> - selected table items are saved into a variable which is initialized in the task constructor. This is necessary because `run()` method is executed in a background thread and cannot access UI components.
<5> - set timeout to 10 minutes
<6> - periodically check `isCancelled()` so that the task can stop immediately after user pressed `Cancel` dialog button
<7> - update progress bar position after every email sent

--

Periodically refresh screen datain the background using Timer and BackgroundTaskWrapper::
+
--
`BackgroundTaskWrapper` is a tiny utility wrapper around `BackgroundWorker`.
It provides simple API for cases when the same type of background task gets started, restarted and cancelled repetitively.

As a usage example, consider the following development task:

- A rank monitoring screen needs to display and automatically update some data.
- Data is loaded slowly and therefore it should be loaded in the background.
- Show time of the latest data update on the screen.
- Data is filtered with simple filter (checkbox).

image::gui_bg_tasks/bg-ranks-ok.png[align="center"]

- If data refresh fails for some reason, the screen should indicate this fact to the user:

image::gui_bg_tasks/bg-ranks-error.png[align="center"]

Sample implementation:
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_sample_ranks.java[]
----
<1> - initialize `BackgroundTaskWrapper` instance with no-arg constructor; for every iteration a new task instance will be supplied
<2> - immediately trigger a background data refresh after checkbox value has changed
<3> - every timer tick triggers a data refresh in the background
<4> - task publishes no progress so progress unit is `Void`; task produces result of type `List<Rank>`
<5> - checkbox state is saved into a variable which is initialized in the task constructor. This is necessary because `run()` method is executed in a background thread and cannot access UI components.
<6> - call custom service to load data (this is the long operation to be executed in the background)
<7> - apply successfully obtained result to screen's components
<8> - update UI in the special case if data loading timed out: show notification in the screen corner
<9> - inform user that data loading has failed with exception by showing notification
--
