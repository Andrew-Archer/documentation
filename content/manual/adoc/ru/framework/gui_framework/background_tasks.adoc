:sourcesdir: ../../../../source

[[background_tasks]]
==== Фоновые задачи

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=standard-progressbar" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Механизм фоновых задач предназначен для асинхронного выполнения длительных операций на клиентском уровне без заморозки пользовательского интерфейса.

Использование фоновых задач:

. Задача описывается как наследник абстрактного класса `BackgroundTask`. В конструктор задачи необходимо передать ссылку на контроллер экрана, с которым будет связана задача, и значение таймаута ее выполнения.
+
Если экран указан, то при его закрытии пользователем активная задача будет прервана. Кроме того, задача будет автоматически прервана по истечении указанного таймаута.
+
Собственно действия, выполняемые задачей, реализуются в методе <<background_tasks_run,run()>>.

. Создается объект управления задачей − `BackgroundTaskHandler`. Для этого экземпляр задачи необходимо передать методу `handle()` бина `BackgroundWorker`. Ссылку на `BackgroundWorker` можно получить инжекцией в <<screen_controller,контроллер экрана>>, либо статическим методом класса `AppBeans`.

. Выполняется запуск задачи.

[WARNING]
====
Метод `run()` класса `BackgroundTask` нельзя использовать для чтения/изменения состояния визуальных компонентов или источников данных: вместо этого используйте методы `done()`, `progress()` и `canceled()`. При попытке установить значение для компонента UI из фонового потока будет выброшено исключение `IllegalConcurrentAccessException`.
====

Пример:

[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_1.java[]
----

Подробная информация о назначении методов приведена в JavaDocs классов `BackgroundTask`, `TaskLifeCycle`, `BackgroundTaskHandler`. 

Ниже приведены моменты, на которые следует обратить внимание:

* `BackgroundTask<T, V>` − параметризованный класс:

** `T` − тип объектов, показывающих прогресс задачи. Объекты этого типа передаются в метод `progress()` задачи при вызове `TaskLifeCycle.publish()` в рабочем потоке.

** `V` − тип результата задачи, он передается в метод `done()`. Его также можно получить вызовом метода `BackgroundTaskHandler.getResult()`, что приведет к ожиданию завершения задачи.

* Метод `canceled()` вызывается только в случае управляемой отмены задачи, то есть при вызове `cancel()` у `TaskHandler`.

* Метод `handleTimeoutException()` вызывается при истечении таймаута задачи. Если окно, в котором выполняется задача, закрывается, то задача останавливается без оповещения.

[[background_tasks_run]]
* Метод `run()` задачи должен поддерживать возможность прерывания извне. Для этого в долгих процессах желательно периодически проверять флаг `TaskLifeCycle.isInterrupted()`, и соответственно завершать выполнение. Кроме того, нельзя тихо проглатывать исключение `InterruptedException` (или вообще все исключения). Вместо этого нужно либо вообще не перехватывать его, либо выполнять корректный выход из метода.
+
** Метод `isCancelled()` возвращает `true`, если задача была прервана вызовом метода `cancel()`.
+
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_2.java[]
----

* Объекты `BackgroundTask` не имеют состояния. Если при реализации конкретного класса задачи не заводить полей для хранения промежуточных данных, то можно запускать несколько параллельно работающих процессов, используя единственный экземпляр задачи.

* Объект `BackgroundHandler` можно запускать (т.е. вызывать его метод `execute()`) всего один раз. Если требуется частый перезапуск задачи, то используйте класс `BackgroundTaskWrapper`.

* Для показа пользователю модального окна с прогрессом и кнопкой *Отмена* используйте классы `BackgroundWorkWindow` или `BackgroundWorkProgressWindow` с набором статических методов.Для окна можно задать режим отображения прогресса и разрешить или запретить отмену фоновой задачи.

* Если внутри потока задачи необходимо использовать некоторые значения визуальных компонентов, то нужно реализовать их получение в методе `getParams()`, который выполняется в потоке UI один раз при запуске задачи. В методе run() эти параметры будут доступны через метод `getParams()` объекта `TaskLifeCycle`.

* При возникновении исключительных ситуаций в потоке UI вызывается метод `BackgroundTask.handleException()`, в котором можно отобразить ошибку.

* На выполнение фоновых задач влияют свойства приложения <<cuba.backgroundWorker.maxActiveTasksCount,cuba.backgroundWorker.maxActiveTasksCount>> и <<cuba.backgroundWorker.timeoutCheckInterval,cuba.backgroundWorker.timeoutCheckInterval>>.

[WARNING]
====
В блоке Web Client фоновые задачи используют технологию HTTP push, предоставляемую фреймворком Vaadin. См. https://vaadin.com/wiki/-/wiki/Main/Working+around+push+issues для получения информации о настройке веб-серверов для использования данной технологии.
====

[TIP]
====
Если вы не используете фоновую задачу, но хотите изменять состояние UI-компонентов из не-UI потока, воспользуйтесь методами интерфейса `UIAccessor`. Получите ссылку на интерфейс `UIAccessor` методом `BackgroundWorker.getUIAccessor()` в UI-потоке, и после этого вы сможете вызывать его методы `access()` и `accessSynchronously()` из фонового потока для безопасного чтения и изменения состояния UI-компонентов.
====

[[background_task_examples]]
===== Примеры использования фоновых задач

Отображение выполнения и управление фоновой задачей с помощью BackgroundWorkProgressWindow::
+
--
Часто при запуске фоновых задач появляется необходимость отображения простого UI:
[loweralpha]
. показать пользователю, что запрошенное действие находится в процессе выполнения,
. дать пользователю возможность прервать запрошенное долгое действие,
. показать процент выполнения, если его можно определить.

Для реализации этих потребностей платформа предоставляет вспомогательные классы `BackgroundWorkWindow` и `BackgroundWorkProgressWindow`.
Эти классы содержат статические методы, позволяющие связать фоновую задачу с модальным диалогом, отображающим заголовок, описание, индикатор прогресса и возможно кнопку `Отмена`.
Разница между этими двумя классами в том, что `BackgroundWorkProgressWindow` использует определённый индикатор прогресса, и оно должно использоваться только если задача может оценить процент своего выполнения.
Класс `BackgroundWorkWindow` следует использовать для задач, где нельзя оценить прогресс выполнения.

В качестве примера рассмотрим следующую задачу по разработке:

- Некоторый экран содержит таблицу, отображающую список студентов, с включенным множественным выделением.
- По нажатию кнопки система должна послать письма-напоминания выбранным студентам, без блокировки UI и с возможностью прервать действие.

image::gui_bg_tasks/bg-task-emails.png[align="center"]

Пример реализации:
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_sample_emails.java[]
----
<1> - запустить задачу и показать модальное окно с прогрессом
<2> - установить опции диалога: "размер" индикатора прогресса, пользователь может прервать задачу, показывать прогресс в процентах
<3> - прогресс задачи измеряется в `Integer` (число обработанных элементов таблицы), а тип результата - `Void`, потому что эта задача не производит результата
<4> - выбранные элементы таблицы сохраняются в переменную, которая инициализируется в конструкторе задачи. Это необходимо, потому что метод `run()` исполняется в фоновом потоке и не может обращаться к UI компонентам.
<5> - установить таймаут равный 10 минутам
<6> - периодически проверяется `isCancelled()`, чтобы задача сразу завершилась после того, как пользователь нажмет кнопку `Cancel`
<7> - обновить индикатор прогресса после каждого посланного письма
--

Периодическое фоновое обновление данных экрана с использованием Timer и BackgroundTaskWrapper::
+
--
`BackgroundTaskWrapper` - это вспомогательный класс, тонкая обертка вокруг `BackgroundWorker`.
Он предоставляет простое API для случаев, когда один и тот же вид фоновой задачи запускается, перезапускается и отменяется много раз.

В качестве примера использования рассмотрим следующую задачу по разработке:

- Имеется экран мониторинга очередей, в котором нужно отображать и автоматически обновлять какие-то табличные данные.
- Данные загружаются медленно, и поэтому их нужно загружать в фоне.
- Нужно отображать на экране время последнего обновления.
- Данные ограничены простым фильтром (флажок checkbox).

image::gui_bg_tasks/bg-ranks-ok.png[align="center"]

- Если обновить данные по каким-то причинам не получилось, то экран должен оповестить об этом пользователя:

image::gui_bg_tasks/bg-ranks-error.png[align="center"]

Пример реализации:
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_sample_ranks.java[]
----
<1> - создать экземпляр `BackgroundTaskWrapper` через конструктор без параметров; для каждой итерации будет передан новый экземпляр задачи
<2> - немедленно запустить фоновое обновление данных после смены состояния флажка
<3> - каждое срабатывание таймера запускает фоновое обновление данных
<4> - задача не публикует ход прогресса, поэтому тип прогресса `Void`; задача производит результат с типом `List<Rank>`
<5> - состояние флажка сохраняется в переменную, которая инициализируется в конструкторе задачи. Это необходимо, потому что метод `run()` выполняется в фоновом потоке и не может обращаться к UI компонентам.
<6> - вызов пользовательского сервиса для загрузки данных (это долгое действие и исполняется в фоновом потоке)
<7> - применить успешно полученный результат к компонентам экрана
<8> - обновить UI в особом случае, если загрузка данных не выполнилась за время таймаута: показать уведомление в углу экрана
<9> - проинформировать пользователя, показав уведомление, если загрузка данных завершилась исключением
--
